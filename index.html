<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <style>
        * { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; touch-action: none; }
        html, body { position: fixed; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; color: #00f2fe; }
        h1 { font-size: 32px; text-shadow: 0 0 15px #00f2fe; margin-bottom: 10px; letter-spacing: 5px; }
        #best-score-menu { color: #f1c40f; font-weight: bold; margin-bottom: 25px; font-size: 14px; }
        .btn-menu { width: 260px; padding: 18px; margin: 10px; border: 2px solid #00f2fe; background: rgba(0, 242, 254, 0.1); color: #fff; font-size: 16px; font-weight: bold; border-radius: 12px; cursor: pointer; }
        .btn-upgrade { border-color: #f1c40f; color: #f1c40f; }
        .btn-back { border-color: #ffffff; color: #ffffff; background: rgba(255, 255, 255, 0.05); }
        
        #ui { position: absolute; top: 15px; left: 15px; color: #00f2fe; pointer-events: none; z-index: 10; display: none; width: calc(100% - 30px); }
        .bar-bg { width: 180px; height: 12px; background: rgba(0,0,0,0.8); border: 1px solid #00f2fe; border-radius: 6px; margin-top: 5px; overflow: hidden; }
        #hp-fill { width: 100%; height: 100%; background: #ff4757; }
        #xp-fill { width: 0%; height: 100%; background: #00f2fe; transition: width 0.1s; }
        
        .touch-btn { pointer-events: auto; cursor: pointer; display: flex; justify-content: center; align-items: center; border-radius: 8px; border: 1px solid #00f2fe; color: #00f2fe; background: rgba(0,242,254,0.1); font-weight: bold; position: absolute; }
        #pause-btn { top: 0; right: 0; width: 50px; height: 50px; }

        .settings-row { display: flex; align-items: center; justify-content: space-between; width: 280px; margin: 15px 0; color: #fff; }
        .toggle-btn { padding: 8px 15px; border: 1px solid #00f2fe; background: none; color: #00f2fe; border-radius: 5px; cursor: pointer; min-width: 100px; }
        .toggle-active { background: #00f2fe; color: #000; }

        #joy-container { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); width: 120px; height: 120px; background: rgba(255,255,255,0.03); border: 2px solid rgba(0,242,254,0.2); border-radius: 50%; z-index: 20; display: none; justify-content: center; align-items: center; }
        #joy-stick { width: 50px; height: 50px; background: #00f2fe; border-radius: 50%; box-shadow: 0 0 15px #00f2fe; }
    </style>
</head>
<body oncontextmenu="return false;">

    <div id="menu" class="overlay">
        <h1>WAR-CORE</h1>
        <div id="best-score-menu">MELHOR NÍVEL: 1</div>
        <button class="btn-menu" onclick="startGame(false)">MODO NORMAL</button>
        <button class="btn-menu" style="border-color:#f1c40f;color:#f1c40f" onclick="accessDV()">DV (SYSTEM)</button>
        <button class="btn-menu" style="border-color:#ff4757;color:#ff4757" onclick="startGame(true)">MODO HARDCORE</button>
        <button class="btn-menu btn-back" onclick="openSettings()">CONFIGURAÇÕES</button>
    </div>

    <div id="settings-screen" class="overlay" style="display: none;">
        <h1>CONFIGS</h1>
        <div class="settings-row">
            <span>CONTROLE:</span>
            <button id="ctrl-toggle" class="toggle-btn" onclick="toggleCtrl()">MOBILE</button>
        </div>
        <div class="settings-row">
            <span>PAUSE ATIVO:</span>
            <button id="pause-toggle" class="toggle-btn toggle-active" onclick="togglePauseConfig()">SIM</button>
        </div>
        <button class="btn-menu btn-back" onclick="closeSettings()">VOLTAR</button>
    </div>

    <div id="pause-screen" class="overlay" style="display: none; background: rgba(0,0,0,0.85);">
        <h1 style="color: #00f2fe;">PAUSADO</h1>
        <button class="btn-menu" onclick="togglePause()">CONTINUAR</button>
        <button class="btn-menu btn-back" onclick="backToMenu()">SAIR PARA O MENU</button>
    </div>

    <div id="upgrade-screen" class="overlay" style="display: none;">
        <h1 style="color: #f1c40f;">UPGRADE</h1>
        <div id="upgrade-options"></div>
    </div>

    <div id="game-over" class="overlay" style="display: none;">
        <h1 style="color: #ff4757;">CORE CRITICAL</h1>
        <p id="stats-final" style="margin-bottom: 25px; color: #fff; font-size: 20px;"></p>
        <button class="btn-menu btn-back" onclick="backToMenu()">VOLTAR AO MENU</button>
    </div>

    <div id="ui">
        <b id="lvl-txt">LVL 1</b>
        <div class="bar-bg"><div id="hp-fill"></div></div>
        <div class="bar-bg"><div id="xp-fill"></div></div>
        <div id="pause-btn" class="touch-btn" onclick="togglePause()">||</div>
    </div>

    <div id="joy-container"><div id="joy-stick"></div></div>
    <canvas id="game"></canvas>

<script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const container = document.getElementById("joy-container");
    const stick = document.getElementById("joy-stick");

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    let config = { control: "MOBILE", pauseEnabled: true };
    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);

    function toggleCtrl() {
        config.control = config.control === "MOBILE" ? "PC" : "MOBILE";
        document.getElementById('ctrl-toggle').innerText = config.control;
        if(gameState === "PLAYING") {
            document.getElementById('joy-container').style.display = config.control === "MOBILE" ? "flex" : "none";
        }
    }

    function togglePauseConfig() {
        config.pauseEnabled = !config.pauseEnabled;
        const btn = document.getElementById('pause-toggle');
        btn.innerText = config.pauseEnabled ? "SIM" : "NÃO";
        btn.classList.toggle('toggle-active');
        document.getElementById('pause-btn').style.display = config.pauseEnabled ? "flex" : "none";
    }

    function openSettings() {
        document.getElementById('settings-screen').style.display = 'flex';
    }

    function closeSettings() {
        document.getElementById('settings-screen').style.display = 'none';
    }

    const WORLD = { w: 3000, h: 3000 };
    let gameState = "MENU", isHardcore = false, isPaused = false;
    let p, enemies, bullets, drops, joyX = 0, joyY = 0, isDragging = false;
    let recoil = 0, lastShootTime = 0, dmgFeedback = 0, shake = 0;
    let shockwave = { active: false, r: 0, maxR: 1200 };
    let particles = []; 
    let galaxyStars = [];
    let currentTarget = null;

    function togglePause() {
        if (!config.pauseEnabled || (gameState !== "PLAYING" && !isPaused)) return;
        isPaused = !isPaused;
        document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';
    }

    function backToMenu() {
        isPaused = false;
        gameState = "MENU"; 
        updateBestScoreUI();
        document.getElementById('pause-screen').style.display = 'none';
        document.getElementById('game-over').style.display = 'none';
        document.getElementById('menu').style.display = 'flex';
        document.getElementById('ui').style.display = 'none';
        document.getElementById('joy-container').style.display = 'none';
    }

    function lerpAngle(a, b, t) {
        let diff = (b - a + Math.PI) % (Math.PI * 2) - Math.PI;
        if (diff < -Math.PI) diff += Math.PI * 2;
        return a + diff * t;
    }

    function initGalaxy() {
        galaxyStars = [];
        for(let i=0; i<800; i++) {
            let angle = Math.random() * Math.PI * 2;
            let distance = Math.random() * 1500;
            let spiral = distance * 0.005; 
            galaxyStars.push({ a: angle + spiral, d: distance, s: Math.random() * 2, c: Math.random() > 0.5 ? "#00f2fe" : "#a29bfe" });
        }
    }
    initGalaxy();

    function drawGalaxy(camX, camY) {
        let gx = WORLD.w/2 - camX; let gy = WORLD.h/2 - camY;
        let grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, 800);
        grad.addColorStop(0, "rgba(0, 242, 254, 0.12)"); grad.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);
        galaxyStars.forEach(s => {
            let x = gx + Math.cos(s.a) * s.d; let y = gy + Math.sin(s.a) * s.d;
            if(x > 0 && x < canvas.width && y > 0 && y < canvas.height) {
                ctx.fillStyle = s.c; ctx.globalAlpha = 0.4; ctx.fillRect(x, y, s.s, s.s);
            }
        });
        ctx.globalAlpha = 1;
    }

    function updateBestScoreUI() {
        const best = localStorage.getItem('warcore_record') || 1;
        document.getElementById('best-score-menu').innerText = `MELHOR NÍVEL ALCANÇADO: ${best}`;
    }

    function checkNewRecord(currentLvl) {
        const best = parseInt(localStorage.getItem('warcore_record') || 1);
        if (currentLvl > best) { localStorage.setItem('warcore_record', currentLvl); return true; }
        return false;
    }

    function accessDV() {
        let code = prompt("INSIRA O CÓDIGO DV:");
        if(code === "123456") {
            let targetLvl = prompt("DEFINIR NÍVEL DE INÍCIO:", "30");
            startGame('dv', parseInt(targetLvl));
        } else { alert("ACESSO NEGADO"); }
    }

    const upgrades = [
        { n: "CADÊNCIA +", f: () => p.rate = Math.max(70, p.rate - 40), hc: true },
        { n: "VELOCIDADE +", f: () => p.speed += 1.5, hc: true },
        { n: "DANO ++", f: () => p.dmg += 1.5, hc: true },
        { n: "REPARO HP", f: () => p.hp = Math.min(100, p.hp + 50), hc: false },
        { n: "IMÃ VORTEX", f: () => p.magnet += 120, hc: true },
        { n: "MULTICANO (+1)", f: () => p.multishot += 1, hc: true }
    ];

    function initGameData(mode, customLvl = 1) {
        p = { x: WORLD.w/2, y: WORLD.h/2, hp: 100, xp: 0, mXp: 8 + (customLvl * 5), lvl: customLvl, angle: 0, rate: 250, speed: 6, dmg: 1, magnet: 25, multishot: 1 };
        enemies = []; bullets = []; drops = []; particles = []; currentTarget = null;
        joyX = 0; joyY = 0; recoil = 0; lastShootTime = 0; dmgFeedback = 0; shake = 0;
        shockwave.active = false; isPaused = false;
    }

    function playerDie() {
        if (gameState === "DEAD") return;
        gameState = "DEAD"; shake = 50;
        for(let i=0; i<40; i++) {
            let a = Math.random()*Math.PI*2; let s = Math.random()*12;
            particles.push({x: p.x, y: p.y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, alpha: 1, w: Math.random()*6, color: '0, 242, 254', decay: 0.02});
        }
        setTimeout(() => {
            document.getElementById('game-over').style.display='flex'; 
            document.getElementById('stats-final').innerText = `NÍVEL: ${p.lvl}`; 
            checkNewRecord(p.lvl); 
        }, 1000);
    }

    function startGame(mode, lvl = 1) {
        isHardcore = (mode === true); initGameData(mode, lvl);
        if(isHardcore) p.hp = 1;
        gameState = "PLAYING";
        document.getElementById('menu').style.display = 'none';
        document.getElementById('game-over').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
        document.getElementById('pause-btn').style.display = config.pauseEnabled ? 'flex' : 'none';
        if(config.control === "MOBILE") document.getElementById('joy-container').style.display = 'flex';
    }

    function triggerShockwave() {
        shockwave.active = true; shockwave.r = 0; enemies = []; drops = []; shake = 25; currentTarget = null;
    }

    function showUpgrade() {
        gameState = "UPGRADE";
        const screen = document.getElementById('upgrade-screen');
        const optDiv = document.getElementById('upgrade-options');
        optDiv.innerHTML = ''; screen.style.display = 'flex';
        let available = upgrades.filter(u => !isHardcore || u.hc);
        let shuff = [...available].sort(() => 0.5 - Math.random()).slice(0, 3);
        shuff.forEach(upg => {
            let b = document.createElement('button');
            b.className = 'btn-menu btn-upgrade';
            b.innerText = upg.n;
            b.onclick = () => { upg.f(); gameState = "PLAYING"; screen.style.display = 'none'; triggerShockwave(); };
            optDiv.appendChild(b);
        });
    }

    function handleMovement() {
        if(config.control === "PC") {
            joyX = 0; joyY = 0;
            if(keys['KeyW'] || keys['ArrowUp']) joyY = -1;
            if(keys['KeyS'] || keys['ArrowDown']) joyY = 1;
            if(keys['KeyA'] || keys['ArrowLeft']) joyX = -1;
            if(keys['KeyD'] || keys['ArrowRight']) joyX = 1;
            if(joyX !== 0 && joyY !== 0) { joyX *= 0.707; joyY *= 0.707; }
        }
        p.x += joyX * p.speed; p.y += joyY * p.speed;
    }

    const moveJoy = (e) => {
        if (isPaused || !isDragging || config.control !== "MOBILE") return;
        const t = e.touches ? e.touches[0] : e;
        const r = container.getBoundingClientRect();
        let dx = t.clientX - (r.left + r.width/2);
        let dy = t.clientY - (r.top + r.height/2);
        const d = Math.hypot(dx, dy);
        if (d > 45) { dx *= 45/d; dy *= 45/d; }
        joyX = dx/45; joyY = dy/45;
        stick.style.transform = `translate(${dx}px, ${dy}px)`;
        if(e.cancelable) e.preventDefault();
    };
    container.addEventListener("touchstart", (e) => { isDragging = true; moveJoy(e); }, { passive: false });
    window.addEventListener("touchmove", moveJoy, { passive: false });
    window.addEventListener("touchend", () => { isDragging = false; if(config.control === "MOBILE") {joyX = 0; joyY = 0;} stick.style.transform = `translate(0,0)`; });

    function createEnemy(x, y, type = "normal") {
        let enX = Math.max(50, Math.min(WORLD.w - 50, x));
        let enY = Math.max(50, Math.min(WORLD.h - 50, y));
        let en = { id: Math.random(), x: enX, y: enY, type, timer: 0, aimAngle: 0, state: "CHASE", stateTimer: 0 };
        if(type === "normal") { en.hp = 2 + p.lvl/3; en.s = 2.2 + p.lvl*0.04; en.size = 30; en.color = "#00f2fe"; en.val = 1; }
        if(type === "orange") { en.hp = 8 + p.lvl/2; en.s = 3.3; en.size = 35; en.color = "#ff9f43"; en.val = 5; }
        if(type === "purple") { en.hp = 35 + p.lvl*2; en.s = 1.8; en.size = 55; en.color = "#a29bfe"; en.val = 1; }
        if(type === "sniper") { en.hp = 12 + p.lvl/2; en.s = 2.4; en.size = 40; en.color = "#ff4757"; en.val = 3; }
        return en;
    }

    function drawWorld(camX, camY) {
        ctx.strokeStyle = "rgba(0, 242, 254, 0.1)"; ctx.lineWidth = 1;
        for (let x = 0; x <= WORLD.w; x += 100) { ctx.beginPath(); ctx.moveTo(x-camX, 0-camY); ctx.lineTo(x-camX, WORLD.h-camY); ctx.stroke(); }
        for (let y = 0; y <= WORLD.h; y += 100) { ctx.beginPath(); ctx.moveTo(0-camX, y-camY); ctx.lineTo(WORLD.w-camX, y-camY); ctx.stroke(); }
        ctx.strokeStyle = "#00f2fe"; ctx.lineWidth = 5; ctx.strokeRect(0-camX, 0-camY, WORLD.w, WORLD.h);
    }

    function drawGun() {
        ctx.save();
        let sX = (Math.random()-0.5) * shake; let sY = (Math.random()-0.5) * shake;
        ctx.translate(p.x - (recoil * Math.cos(p.angle)) + sX, p.y - (recoil * Math.sin(p.angle)) + sY);
        ctx.rotate(p.angle);
        ctx.fillStyle = dmgFeedback > 0 ? "#ff0000" : "#333";
        ctx.fillRect(-15, -12, 30, 24);
        ctx.fillStyle = dmgFeedback > 0 ? "#fff" : (isHardcore ? "#ff4757" : "#00f2fe");
        ctx.fillRect(-5, -13, 15, 2); ctx.fillRect(-5, 11, 15, 2);
        for(let i=0; i<p.multishot; i++) {
            let yOff = (i - (p.multishot-1)/2) * 12;
            ctx.fillStyle = dmgFeedback > 0 ? "#ff0000" : "#222";
            ctx.strokeStyle = dmgFeedback > 0 ? "#fff" : (isHardcore ? "#ff4757" : "#00f2fe");
            ctx.lineWidth = 2; ctx.fillRect(15, yOff - 4, 25, 8); ctx.strokeRect(15, yOff - 4, 25, 8);
        }
        ctx.restore();
        if(!isPaused) {
            if(recoil > 0) recoil -= 1; if(dmgFeedback > 0) dmgFeedback -= 1; if(shake > 0) shake *= 0.9;
        }
    }

    function loop(time) {
        if(gameState === "PLAYING" || gameState === "UPGRADE" || gameState === "DEAD") {
            ctx.fillStyle = "#010101"; ctx.fillRect(0,0,canvas.width,canvas.height);
            
            if(gameState === "PLAYING" && !isPaused) {
                handleMovement();
                p.x = Math.max(0, Math.min(WORLD.w, p.x)); p.y = Math.max(0, Math.min(WORLD.h, p.y));
            }
            
            let camX = p.x - canvas.width/2; let camY = p.y - canvas.height/2;
            if(shake > 1) { camX += (Math.random()-0.5)*shake; camY += (Math.random()-0.5)*shake; }
            
            drawGalaxy(camX, camY); drawWorld(camX, camY);
            ctx.save(); ctx.translate(-camX, -camY);

            particles.forEach((pt, pi) => {
                if(!isPaused) { pt.alpha -= (pt.decay || 0.05); pt.x += pt.vx; pt.y += pt.vy; }
                ctx.strokeStyle = pt.color ? `rgba(${pt.color}, ${pt.alpha})` : `rgba(255, 255, 255, ${pt.alpha})`;
                ctx.lineWidth = pt.w; ctx.beginPath(); ctx.moveTo(pt.x, pt.y); ctx.lineTo(pt.x - pt.vx*3.5, pt.y - pt.vy*3.5); ctx.stroke();
                if(pt.alpha <= 0) particles.splice(pi, 1);
            });

            if(shockwave.active) {
                if(!isPaused) shockwave.r += 45; 
                ctx.beginPath(); ctx.arc(p.x, p.y, shockwave.r, 0, Math.PI*2);
                ctx.strokeStyle = `rgba(0, 242, 254, ${1 - shockwave.r/shockwave.maxR})`; ctx.lineWidth = 40; ctx.stroke();
                if(shockwave.r >= shockwave.maxR) shockwave.active = false;
            }

            if(gameState === "PLAYING") {
                if(!isPaused && Math.random() < 0.05 && enemies.length < 50) {
                    let a = Math.random()*Math.PI*2;
                    let type = p.lvl >= 30 && Math.random() < 0.15 ? "sniper" : (p.lvl >= 20 && Math.random() < 0.15 ? "purple" : (p.lvl >= 10 && Math.random() < 0.3 ? "orange" : "normal"));
                    enemies.push(createEnemy(p.x+Math.cos(a)*750, p.y+Math.sin(a)*750, type));
                }

                if (currentTarget && !enemies.some(e => e.id === currentTarget.id)) currentTarget = null;
                let sorted = enemies.sort((a,b) => Math.hypot(a.x-p.x, a.y-p.y) - Math.hypot(b.x-p.x, b.y-p.y));
                let closest = sorted[0];

                if (closest && !isPaused) {
                    if (!currentTarget) currentTarget = closest;
                    else if (Math.hypot(closest.x-p.x, closest.y-p.y) < Math.hypot(currentTarget.x-p.x, currentTarget.y-p.y) - 50) currentTarget = closest;
                    
                    let targetAngle = Math.atan2(currentTarget.y-p.y, currentTarget.x-p.x);
                    p.angle = lerpAngle(p.angle, targetAngle, 0.18); 

                    if(time - lastShootTime > p.rate) {
                        lastShootTime = time; recoil = 10;
                        for(let i=0; i<p.multishot; i++){
                            let off = (i-(p.multishot-1)/2)*0.15;
                            bullets.push({x:p.x, y:p.y, vx:Math.cos(p.angle+off)*18, vy:Math.sin(p.angle+off)*18});
                        }
                    }
                }
            }

            enemies.forEach((en, i) => {
                let dist = Math.hypot(p.x-en.x, p.y-en.y); let ang = Math.atan2(p.y-en.y, p.x-en.x);
                if(gameState === "PLAYING" && !isPaused) {
                    if(en.type === "orange") {
                        // Partículas de rastro brancas para o inimigo laranja
                        if(Math.random() < 0.4) {
                            particles.push({x: en.x, y: en.y, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, alpha: 0.6, w: 2, color: '255, 255, 255', decay: 0.04});
                        }
                        en.stateTimer--;
                        if(en.state === "CHASE") {
                            en.x += Math.cos(ang)*en.s; en.y += Math.sin(ang)*en.s;
                            if(dist < 320) { en.state = "PRE_DASH"; en.stateTimer = 25; en.dashAng = ang; }
                        } else if(en.state === "PRE_DASH") {
                            if(en.stateTimer <= 0) { en.state = "DASH"; en.stateTimer = 18; }
                        } else if(en.state === "DASH") {
                            en.x += Math.cos(en.dashAng)*en.s*4; en.y += Math.sin(en.dashAng)*en.s*4;
                            if(en.stateTimer <= 0) { en.state = "CHASE"; en.stateTimer = 30; }
                        }
                    } else if(en.type === "sniper") {
                        if(dist > 520) { en.x += Math.cos(ang)*en.s; en.y += Math.sin(ang)*en.s; }
                        else if(dist < 380) { en.x -= Math.cos(ang)*en.s; en.y -= Math.sin(ang)*en.s; }
                    } else { en.x += Math.cos(ang)*en.s; en.y += Math.sin(ang)*en.s; }
                }

                if(en.type === "orange" && en.state === "PRE_DASH") {
                    ctx.beginPath(); ctx.strokeStyle = "rgba(255, 255, 255, 0.3)"; ctx.setLineDash([5, 5]); 
                    ctx.moveTo(en.x, en.y); ctx.lineTo(en.x + Math.cos(en.dashAng)*400, en.y + Math.sin(en.dashAng)*400);
                    ctx.stroke(); ctx.setLineDash([]);
                    if(en.stateTimer % 4 < 2) ctx.strokeStyle = "#fff"; else ctx.strokeStyle = "#ff9f43";
                } else { ctx.strokeStyle = en.color; }

                if(en.type === "sniper") {
                    if(!isPaused) en.timer++; 
                    let predX = p.x + (joyX * p.speed * 12); let predY = p.y + (joyY * p.speed * 12);
                    en.aimAngle = Math.atan2(predY - en.y, predX - en.x);
                    ctx.save();
                    if(en.timer > 80) { ctx.strokeStyle = "#ff4757"; ctx.lineWidth = 3; }
                    else { ctx.strokeStyle = "rgba(255, 71, 87, 0.4)"; ctx.setLineDash([10, 10]); }
                    ctx.beginPath(); ctx.moveTo(en.x, en.y); ctx.lineTo(en.x + Math.cos(en.aimAngle)*2000, en.y + Math.sin(en.aimAngle)*2000); ctx.stroke();
                    ctx.restore();
                    if(en.timer > 110 && !isPaused) {
                        let dot = (Math.cos(en.aimAngle)*(p.x-en.x) + Math.sin(en.aimAngle)*(p.y-en.y)) / dist;
                        if(dot > 0.995 && dist < 2000 && gameState === "PLAYING") {
                            if(isHardcore) p.hp = 0; else p.hp -= 35; shake = 40; dmgFeedback = 15;
                            if(p.hp <= 0) { p.hp = 0; playerDie(); }
                        }
                        en.timer = 0;
                    }
                }
                
                ctx.lineWidth = 2;
                ctx.strokeRect(en.x - en.size/2, en.y - en.size/2, en.size, en.size);
                
                if(!isPaused && dist < en.size/2 + 15 && gameState === "PLAYING") {
                    dmgFeedback = 12; shake = 25; 
                    if(isHardcore) p.hp = 0; else p.hp -= 4;
                    if(p.hp <= 0) { p.hp = 0; playerDie(); }
                }
            });

            bullets.forEach((b, bi) => {
                if(!isPaused) { b.x+=b.vx; b.y+=b.vy; }
                ctx.fillStyle="#fff"; ctx.fillRect(b.x,b.y,5,5);
                enemies.forEach((en, ei) => {
                    if(Math.hypot(b.x-en.x, b.y-en.y) < en.size/2 + 12) {
                        if(!isPaused) {
                            en.hp -= p.dmg; bullets.splice(bi, 1);
                            if(en.hp<=0) {
                                // Partículas de explosão brancas e em maior quantidade para o laranja
                                if(en.type === "orange") {
                                    for(let k=0; k<40; k++) {
                                        let a = Math.random()*Math.PI*2; let s = Math.random()*7;
                                        particles.push({x: en.x, y: en.y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, alpha: 1, w: 3, color: '255, 255, 255', decay: 0.02});
                                    }
                                }
                                for(let k=0; k<en.val; k++) drops.push({x: en.x+(Math.random()-0.5)*20, y: en.y+(Math.random()-0.5)*20});
                                if(en.type === "purple") {
                                    enemies.push(createEnemy(en.x - 25, en.y, "orange"));
                                    enemies.push(createEnemy(en.x + 25, en.y, "orange"));
                                }
                                enemies.splice(ei,1); 
                            }
                        }
                    }
                });
            });

            drops.forEach((d, i) => {
                let distD = Math.hypot(p.x-d.x, p.y-d.y);
                if(!isPaused && distD < p.magnet) { let aD = Math.atan2(p.y-d.y, p.x-d.x); d.x += Math.cos(aD)*12; d.y += Math.sin(aD)*12; }
                ctx.fillStyle = "#00f2fe"; ctx.beginPath(); ctx.arc(d.x, d.y, 5, 0, 7); ctx.fill();
                if(!isPaused && distD < 25) { p.xp++; drops.splice(i,1); if(p.xp >= p.mXp) { p.lvl++; p.xp=0; p.mXp+=5; if(p.lvl%5===0) showUpgrade(); } }
            });
            
            if(gameState !== "DEAD") drawGun(); ctx.restore();
            document.getElementById('hp-fill').style.width = Math.max(0, p.hp) + "%";
            document.getElementById('xp-fill').style.width = (p.xp/p.mXp*100) + "%";
            document.getElementById('lvl-txt').innerText = "SISTEMA: LVL " + p.lvl;
        }
        requestAnimationFrame(loop);
    }
    updateBestScoreUI(); requestAnimationFrame(loop);
</script>
</body>
</html>
